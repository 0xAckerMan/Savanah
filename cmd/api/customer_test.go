// customer tests
package main

import (
	"net/http"
	"strings"
	"testing"
	"io"
	"net/http/httptest"
	"log"
	"os"
	"gorm.io/gorm"
	"gorm.io/driver/postgres"
)

func NewApplication() (*Application, error) {
	var cfg Config

	cfg.port = 4000
	cfg.env = "development"
	cfg.db.dsn = "postgres://postgres:password@localhost/savanah?sslmode=disable"

	logger := log.New(os.Stdout, "", log.LstdFlags)

	db, err := gorm.Open(postgres.Open(cfg.db.dsn), &gorm.Config{})
	if err != nil {
		return nil, err
	}

	DB, err := db.DB()
	if err != nil {
		return nil, err
	}
	defer DB.Close()

	logger.Printf("database connection pool established")

	app := &Application{
		config: cfg,
		logger: logger,
		DB:     db,
	}

	return app, nil
}

func newTestApplication(t *testing.T) *Application {
	t.Helper()
	app, err := NewApplication()
	if err != nil {
		t.Fatal(err)
	}
	return app
}

func TestCreateCustomer(t *testing.T) {
	// Create a new instance of our application struct which contains the dependencies
	// needed by the handler.
	app := newTestApplication(t)

	// Create a new instance of a http.Request, setting the method to POST, the target
	// URL to the /v1/customers path, and the request body to a JSON string containing a
	// valid customer.
	body := `{"name": "Test User", "email": "test@mail.com", "password": "password123"}`
	r, err := http.NewRequest("POST", "/v1/customers", strings.NewReader(body))
	if err != nil {
		t.Fatal(err)
	}

	// Create a new httptest.ResponseRecorder.
	w := httptest.NewRecorder()

	// Call the createCustomer handler method, passing in the http.ResponseRecorder and
	// http.Request as the response and request respectively.
	app.SignUpCustomer(w, r)

	// Call the Result() method on the http.ResponseRecorder to get the http.Response
	// generated by the handler.
	rs := w.Result()

	// Check the response status code is 201.
	if rs.StatusCode != http.StatusCreated {
		t.Errorf("expected status 201; got %d", rs.StatusCode)
	}

	// Check the response body is as expected.
	expected := `{"id":1,"name":"Test User","email":"test@mail.com"}`

	// Read the response body from the http.Response.
	b, err := io.ReadAll(rs.Body)
	if err != nil {
		t.Fatal(err)
	}

	// Check the response body is what we expect.
	if string(b) != expected {
		t.Errorf("expected body %q; got %q", expected, string(b))
	}
}

func TestGetCustomer(t *testing.T) {
	// Create a new instance of our application struct which contains the dependencies
	// needed by the handler.
	app := newTestApplication(t)

	// Create a new instance of a http.Request, setting the method to GET, the target
	// URL to the /v1/customers/1 path, and the request body to nil.
	r, err := http.NewRequest("GET", "/v1/customers/1", nil)
	if err != nil {
		t.Fatal(err)
	}

	// Create a new httptest.ResponseRecorder.
	w := httptest.NewRecorder()

	// Call the getCustomer handler method, passing in the http.ResponseRecorder and
	// http.Request as the response and request respectively.
	app.handle_getSingleCustomer(w, r)

	// Call the Result() method on the http.ResponseRecorder to get the http.Response
	// generated by the handler.
	rs := w.Result()

	// Check the response status code is 200.
	if rs.StatusCode != http.StatusOK {
		t.Errorf("expected status 200; got %d", rs.StatusCode)
	}

	// Check the response body is as expected.
	expected := `{"id":1,"name":"Test User","email":"test@mail.com"}`
	b, err := io.ReadAll(rs.Body)
	if err != nil {
		t.Fatal(err)
	}
	if string(b) != expected {
		t.Errorf("expected body %q; got %q", expected, string(b))
	}
}